<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on hansomxue99&#39;s blog</title>
		<link>https://hansomxue99.github.io/posts/</link>
		<description>Recent content in Posts on hansomxue99&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-CN</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 13 Feb 2021 09:42:04 +0800</lastBuildDate>
		<atom:link href="https://hansomxue99.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>基于HAL中断的串口收发</title>
			<link>https://hansomxue99.github.io/posts/uart_it/</link>
			<pubDate>Sat, 13 Feb 2021 09:42:04 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/uart_it/</guid>
			<description>1. 串口中断的配置——使用cubemx软件 （1）配置时钟
（2）配置通用GPIO
（3）使能串口：GPIO、串口基本参数、NVIC中断函数
2. HAL库中断处理机制 （1）NVIC，嵌套向量中断控制器，用来决定中断的优先级；NVIC在Conrtex-M内核中（2）中断优先级用一个8位寄存器来进行配置，其中低4位全部置为0（为节约内核资源），因此只有高4为配置优先级。中断优先级分为五个分组，它们的抢占优先级和子优先级都不同，具体如下表：
   优先级分组 抢占优先级占的位数 子优先级占的位数     NVIC_PriorityGroup_0 0 bit 4 bit   NVIC_PriorityGroup_1 1 bit 3 bit   NVIC_PriorityGroup_2 2 bit 2 bit   NVIC_PriorityGroup_3 3 bit 1 bit   NVIC_PriorityGroup_4 4 bit 0 bit    （3）CPU优先级的判断
 先判断抢占优先级，数字越小，优先级越高； 若抢占优先级相同，判断子优先级，同样，数字越小，优先级越高。  3. HAL中断回调函数 （1）中断的实现一般是通过中断回调函数，如： __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
（2）中断回调函数函数用__weak进行声明，表明该函数是虚函数，用户调用中断时需要对其进行重定义，可以在工程任意文件下进行重定义。
（3）重定义串口中断回调函数
/* USER CODE BEGIN 4 */ void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { /* 判断是哪个串口触发的中断 */ if(huart -&amp;gt;Instance == USART1) { if(rec_dat==&amp;#39;\n&amp;#39;) { HAL_UART_Transmit_IT(&amp;amp;huart1, rec_buf, ulength); ulength=0; } else { rec_buf[ulength++]=rec_dat; } //重新使能串口接收中断 	HAL_UART_Receive_IT(huart, &amp;amp;rec_dat, 1); } } /* USER CODE END 4 */ 4.</description>
			<content type="html"><![CDATA[<h2 id="1-串口中断的配置使用cubemx软件">1. 串口中断的配置——使用cubemx软件</h2>
<p>（1）配置时钟</p>
<p>（2）配置通用GPIO</p>
<p>（3）使能串口：GPIO、串口基本参数、NVIC中断函数</p>
<h2 id="2-hal库中断处理机制">2. HAL库中断处理机制</h2>
<p>（1）NVIC，嵌套向量中断控制器，用来决定中断的优先级；NVIC在Conrtex-M内核中<!-- raw HTML omitted -->
（2）中断优先级用一个8位寄存器来进行配置，其中低4位全部置为0（为节约内核资源），因此只有高4为配置优先级。中断优先级分为五个分组，它们的抢占优先级和子优先级都不同，具体如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">优先级分组</th>
<th style="text-align:center">抢占优先级占的位数</th>
<th style="text-align:center">子优先级占的位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NVIC_PriorityGroup_0</td>
<td style="text-align:center">0 bit</td>
<td style="text-align:center">4 bit</td>
</tr>
<tr>
<td style="text-align:left">NVIC_PriorityGroup_1</td>
<td style="text-align:center">1 bit</td>
<td style="text-align:center">3 bit</td>
</tr>
<tr>
<td style="text-align:left">NVIC_PriorityGroup_2</td>
<td style="text-align:center">2 bit</td>
<td style="text-align:center">2 bit</td>
</tr>
<tr>
<td style="text-align:left">NVIC_PriorityGroup_3</td>
<td style="text-align:center">3 bit</td>
<td style="text-align:center">1 bit</td>
</tr>
<tr>
<td style="text-align:left">NVIC_PriorityGroup_4</td>
<td style="text-align:center">4 bit</td>
<td style="text-align:center">0 bit</td>
</tr>
</tbody>
</table>
<p>（3）CPU优先级的判断</p>
<ul>
<li>先判断抢占优先级，数字越小，优先级越高；</li>
<li>若抢占优先级相同，判断子优先级，同样，数字越小，优先级越高。</li>
</ul>
<h2 id="3-hal中断回调函数">3. HAL中断回调函数</h2>
<p>（1）中断的实现一般是通过中断回调函数，如：
<code>__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</code></p>
<p>（2）中断回调函数函数用__weak进行声明，表明该函数是虚函数，用户调用中断时需要对其进行重定义，可以在工程任意文件下进行重定义。</p>
<p>（3）重定义串口中断回调函数</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* USER CODE BEGIN 4 */</span>
<span class="kt">void</span> <span class="nf">HAL_UART_RxCpltCallback</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span> <span class="o">*</span><span class="n">huart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 判断是哪个串口触发的中断 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">huart</span> <span class="o">-&gt;</span><span class="n">Instance</span> <span class="o">==</span> <span class="n">USART1</span><span class="p">)</span>
	<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">rec_dat</span><span class="o">==</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">HAL_UART_Transmit_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">rec_buf</span><span class="p">,</span> <span class="n">ulength</span><span class="p">);</span>
				<span class="n">ulength</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">rec_buf</span><span class="p">[</span><span class="n">ulength</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">rec_dat</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">//重新使能串口接收中断
</span><span class="c1"></span>			<span class="n">HAL_UART_Receive_IT</span><span class="p">(</span><span class="n">huart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec_dat</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* USER CODE END 4 */</span>
</code></pre></div><h2 id="4-串口收发">4. 串口收发</h2>
<p>（1）发送使用函数<code>HAL_UART_Transmit_IT</code></p>
<ul>
<li>注意：<code>HAL_UART_Transmit_IT</code>不能连续使用，只会发送第二次</li>
<li>要想连续使用<code>HAL_UART_Transmit_IT</code>，必须添加代码<code>while(huart1.gState != HAL_UART_STATE_READY);</code></li>
<li>串口发送一般不使用中断，而使用轮询模式</li>
</ul>
<p>（2）接收前必须先要使能中断接收，使用函数<code>HAL_UART_Receive_IT</code></p>
<h2 id="5-串口发送printf的重定向">5. 串口发送printf的重定向</h2>
<p>所以，重定向fputc()函数完整的代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#if 1
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 告知连接器不从C库链接使用半主机的函数 */</span>
<span class="cp">#pragma import(__use_no_semihosting)
</span><span class="cp"></span>
<span class="cm">/* 定义 _sys_exit() 以避免使用半主机模式 */</span>
<span class="kt">void</span> <span class="nf">_sys_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 标准库需要的支持类型 */</span>
<span class="k">struct</span> <span class="n">__FILE</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">FILE</span> <span class="n">__stdout</span><span class="p">;</span>

<span class="cm">/*  */</span>
<span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 堵塞判断串口是否发送完成 */</span>
    <span class="k">while</span><span class="p">((</span><span class="n">USART1</span><span class="o">-&gt;</span><span class="n">ISR</span> <span class="o">&amp;</span> <span class="mi">0</span><span class="n">X40</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* 串口发送完成，将该字符发送 */</span>
    <span class="n">USART1</span><span class="o">-&gt;</span><span class="n">TDR</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span> <span class="n">ch</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div><h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.mculover666.cn/posts/2504113390/">STM32CubeMX_05 | 使用EXIT中断检测按键</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>UART异步串口通信</title>
			<link>https://hansomxue99.github.io/posts/uart/</link>
			<pubDate>Wed, 10 Feb 2021 10:48:50 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/uart/</guid>
			<description>1. 什么是UART？ （1）UART，通用异步收发器。相比于USART，UART收发是以字符为单位，没有CLK同步时钟。 （2）UART最主要的是三根数据线：  TXD发送引脚 RXD接收引脚 GND接地引脚  （3）UART比较重要的几个参数：  波特率：每秒传送的码元数，比如9600，115200 数据位：典型值5、6、8、9位 奇偶校验位：一般分为奇校验和偶校验或者无校验位 停止位：典型值1、1.5、2位  （4）UART工作示意图如下图所示：   UART工作模式
  这是典型的UART异步通信模式，数据位为8，无奇偶校验位，一位停止位。UART串口发送一次包含：起始位，数据位（低位在前），奇偶校验位（可选），以及停止位。2. 以STM32为例，分析UART工作原理 （1）了解STM32串口主要特性  可编程数据字长度(8位或9位) 可配置的停止位-支持1或2个停止位 可配置的使用DMA的多缓冲器通信 单独的发送器和接收器使能位 检测标志：接收缓冲器满、发送缓冲器空、传输结束标志  （2）了解STM32串口主要寄存器 STM32串口工作流程如下图：   UART工作流程
   状态寄存器USART_SR
  TXE（发送数据寄存器空），当数据全部移入发送移位寄存器时，置1 TC（发送完成），当一帧数据发送完成，且TXE=1时，置1 RXNE（读数据寄存器非空），当有数据读入数据寄存器USART_DR时，置1   数据寄存器USART_DR，发送或接收缓存数据
  控制寄存器1 USART_CR1，主要用于配置中断和使能
  UE（USART使能），TE（发送使能），RE（接收使能） TXEIE 发送缓冲区空中断使能 TCIE 发送完成中断使能 RXNEIE 接收缓冲区非空中断使能  （3）STM32基本配置：波特率，数据位，奇偶校验位，停止位，串口/中断使能 3. UART发送数据 （1）首先是对UART串口的初始化配置 （2）调用函数 HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)  huart是UART句柄结构体（姑且先这么叫） pData是待发送的字符数组，每次发送前都需要进行一次读写，可以调用sprintf函数 Size是指pData字符数组的长度，一般是strlen(pData) Timeout是待发送数据的生存时间，若超时会返回HAL_TIMEOUT  （3）自定义函数usUART_sendString(UART_HandleTypeDef *huart, uint8_t *pData)  这是根据HAL库发送函数由用户进行改写的字符串发送函数，形参只有两个 函数编写借鉴51单片机串口思想，代码编写如下：  void usUart_sendString(UART_HandleTypeDef *huart, uint8_t *pData) { /* 判断是否发送完成 */ while(*pData) { /* 每次发送一个字符 */ HAL_StatusTypeDef HAL_UART_Transmit(huart, pData, 1, 0xffff); /* 字符指针移位，指向下一个字符的内容 */ pData++; } } 4.</description>
			<content type="html"><![CDATA[<h2 id="1-什么是uart">1. 什么是UART？</h2>
<h3 id="1uart通用异步收发器相比于usartuart收发是以字符为单位没有clk同步时钟">（1）UART，通用异步收发器。相比于USART，UART收发是以字符为单位，没有CLK同步时钟。</h3>
<h3 id="2uart最主要的是三根数据线br">（2）UART最主要的是三根数据线：<!-- raw HTML omitted --></h3>
<ul>
<li>TXD发送引脚<!-- raw HTML omitted --></li>
<li>RXD接收引脚<!-- raw HTML omitted --></li>
<li>GND接地引脚<!-- raw HTML omitted --></li>
</ul>
<h3 id="3uart比较重要的几个参数br">（3）UART比较重要的几个参数：<!-- raw HTML omitted --></h3>
<ul>
<li>波特率：每秒传送的码元数，比如9600，115200<!-- raw HTML omitted --></li>
<li>数据位：典型值5、6、8、9位<!-- raw HTML omitted --></li>
<li>奇偶校验位：一般分为奇校验和偶校验或者无校验位<!-- raw HTML omitted --></li>
<li>停止位：典型值1、1.5、2位<!-- raw HTML omitted --></li>
</ul>
<h3 id="4uart工作示意图如下图所示">（4）UART工作示意图如下图所示：</h3>
<figure>
    <img src="https://img-blog.csdnimg.cn/20210210180902920.png"
         alt="image"/> <figcaption>
            <p>UART工作模式</p>
        </figcaption>
</figure>

<p>这是典型的UART异步通信模式，数据位为8，无奇偶校验位，一位停止位。UART串口发送一次包含：起始位，数据位（低位在前），奇偶校验位（可选），以及停止位。<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<h2 id="2-以stm32为例分析uart工作原理">2. 以STM32为例，分析UART工作原理</h2>
<h3 id="1了解stm32串口主要特性">（1）了解STM32串口主要特性</h3>
<ul>
<li>可编程数据字长度(8位或9位)</li>
<li>可配置的停止位-支持1或2个停止位</li>
<li>可配置的使用DMA的多缓冲器通信</li>
<li>单独的发送器和接收器使能位</li>
<li>检测标志：接收缓冲器满、发送缓冲器空、传输结束标志</li>
</ul>
<h3 id="2了解stm32串口主要寄存器">（2）了解STM32串口主要寄存器</h3>
<p>STM32串口工作流程如下图：
<figure>
    <img src="https://img-blog.csdnimg.cn/20210210183410273.png"
         alt="image"/> <figcaption>
            <p>UART工作流程</p>
        </figcaption>
</figure>
</p>
<blockquote>
<p>状态寄存器USART_SR</p>
</blockquote>
<ul>
<li>TXE（发送数据寄存器空），当数据全部移入发送移位寄存器时，置1</li>
<li>TC（发送完成），当一帧数据发送完成，且TXE=1时，置1</li>
<li>RXNE（读数据寄存器非空），当有数据读入数据寄存器USART_DR时，置1</li>
</ul>
<blockquote>
<p>数据寄存器USART_DR，发送或接收缓存数据</p>
</blockquote>
<blockquote>
<p>控制寄存器1 USART_CR1，主要用于配置中断和使能</p>
</blockquote>
<ul>
<li>UE（USART使能），TE（发送使能），RE（接收使能）</li>
<li>TXEIE 发送缓冲区空中断使能</li>
<li>TCIE 发送完成中断使能</li>
<li>RXNEIE 接收缓冲区非空中断使能</li>
</ul>
<h3 id="3stm32基本配置波特率数据位奇偶校验位停止位串口中断使能">（3）STM32基本配置：波特率，数据位，奇偶校验位，停止位，串口/中断使能</h3>
<h2 id="3-uart发送数据">3. UART发送数据</h2>
<h3 id="1首先是对uart串口的初始化配置">（1）首先是对UART串口的初始化配置</h3>
<h3 id="2调用函数-hal_statustypedef-hal_uart_transmituart_handletypedef-huart-uint8_t-pdata-uint16_t-size-uint32_t-timeout">（2）调用函数 <code>HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</code></h3>
<ul>
<li>huart是UART句柄结构体（姑且先这么叫）</li>
<li>pData是待发送的字符数组，每次发送前都需要进行一次读写，可以调用sprintf函数</li>
<li>Size是指pData字符数组的长度，一般是<code>strlen(pData)</code></li>
<li>Timeout是待发送数据的生存时间，若超时会返回HAL_TIMEOUT</li>
</ul>
<h3 id="3自定义函数usuart_sendstringuart_handletypedef-huart-uint8_t-pdata">（3）自定义函数<code>usUART_sendString(UART_HandleTypeDef *huart, uint8_t *pData)</code></h3>
<ul>
<li>这是根据HAL库发送函数由用户进行改写的字符串发送函数，形参只有两个</li>
<li>函数编写借鉴51单片机串口思想，代码编写如下：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">usUart_sendString</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span> <span class="o">*</span><span class="n">huart</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="o">*</span><span class="n">pData</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/*
</span><span class="cm">  判断是否发送完成
</span><span class="cm">  */</span>
  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">pData</span><span class="p">)</span>   
  <span class="p">{</span>
    <span class="cm">/*
</span><span class="cm">    每次发送一个字符
</span><span class="cm">    */</span>
    <span class="n">HAL_StatusTypeDef</span> <span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="n">huart</span><span class="p">,</span> <span class="n">pData</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">    字符指针移位，指向下一个字符的内容
</span><span class="cm">    */</span>
    <span class="n">pData</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="4-uart接收">4. UART接收</h2>
<h3 id="1首先对uart串口进行初始化">（1）首先对UART串口进行初始化</h3>
<h3 id="2调用函数hal_statustypedef-hal_uart_receiveuart_handletypedef-huart-uint8_t-pdata-uint16_t-size-uint32_t-timeout">（2）调用函数<code>HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</code></h3>
<ul>
<li>采用这种方法一般都是查询法，如下：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 判断是否接收成功 */</span>
<span class="k">if</span><span class="p">(</span><span class="n">HAL_UART_Receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uRx_Data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="n">HAL_OK</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* 将接收成功的数据通过串口发出来 */</span>
  <span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uRx_Data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>这种方式接收，必须事先知晓接收数据的长度，否则大概率会出错；其次，采用此方法会严重占用MCU的资源，尤其是放到while函数中。</li>
<li>除此之外，若是采用中断的方法，像这样接收后直接处理，就会出现另一个问题，即，还未发送出去（移位寄存器还未清空）就直接进入下一次中断</li>
</ul>
<h3 id="3采用中断方式接收完成后再处理">（3）采用中断方式（接收完成后再处理）</h3>
<ul>
<li>首先需要配置中断，中断配置在此略过……</li>
<li>中断函数代码编写如下：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">* @brief This function handles USART1 global interrupt.
</span><span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">USART1_IRQHandler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">uRx_Data</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>     <span class="p">;</span>    <span class="c1">//存储数组
</span><span class="c1"></span>  <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pRx_Data</span>       <span class="o">=</span> <span class="n">uRx_Data</span><span class="p">;</span>    <span class="c1">//指向存储数组将要存储数据的位
</span><span class="c1"></span>  <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">uLength</span>        <span class="o">=</span>  <span class="mi">0</span>      <span class="p">;</span>    <span class="c1">//接收数据长度
</span><span class="c1"></span>
  <span class="cm">/* -1- 接收数据 */</span>
  <span class="n">HAL_UART_Receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">pRx_Data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

  <span class="cm">/* -2- 判断数据结尾 */</span>
  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pRx_Data</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="cm">/* -3- 将接收成功的数据通过串口发出去 */</span>
      <span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span> <span class="n">uRx_Data</span><span class="p">,</span> <span class="n">uLength</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>

      <span class="cm">/* -4- 初始化指针和数据长度 */</span>
      <span class="n">pRx_Data</span> <span class="o">=</span> <span class="n">uRx_Data</span><span class="p">;</span>   <span class="c1">//重新指向数组起始位置
</span><span class="c1"></span>      <span class="n">uLength</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">//长度清零
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="cm">/* -5- 若未结束，指针往下一位移动，长度自增一 */</span>
  <span class="k">else</span>
  <span class="p">{</span>
      <span class="n">pRx_Data</span><span class="o">++</span><span class="p">;</span>
      <span class="n">uLength</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">HAL_UART_IRQHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="参考资料">参考资料</h2>
<p>[1] <a href="https://www.cnblogs.com/ChurF-Lin/p/10809000.html">基于STM32之UART串口通信协议（三）接收</a></p>
<p>[2] <a href="https://www.bilibili.com/video/BV1f7411G7qc?t=217">UART串口通信协议原理</a></p>
]]></content>
		</item>
		
	</channel>
</rss>
