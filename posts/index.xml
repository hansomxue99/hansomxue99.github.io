<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on hansomxue99&#39;s blog</title>
		<link>https://hansomxue99.github.io/posts/</link>
		<description>Recent content in Posts on hansomxue99&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-CN</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 10 Feb 2021 10:48:50 +0800</lastBuildDate>
		<atom:link href="https://hansomxue99.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Uart异步串口通信</title>
			<link>https://hansomxue99.github.io/posts/uart/</link>
			<pubDate>Wed, 10 Feb 2021 10:48:50 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/uart/</guid>
			<description>1. 什么是UART？ （1）UART，通用异步收发器。相比于USART，UART收发是以字符为单位，没有CLK同步时钟。 （2）UART最主要的是三根数据线：  TXD发送引脚 RXD接收引脚 GND接地引脚  （3）UART比较重要的几个参数：  波特率：每秒传送的码元数，比如9600，115200 数据位：典型值5、6、8、9位 奇偶校验位：一般分为奇校验和偶校验或者无校验位 停止位：典型值1、1.5、2位  （4）UART工作示意图如下图所示：   UART工作模式
  这是典型的UART异步通信模式，数据位为8，无奇偶校验位，一位停止位。UART串口发送一次包含：起始位，数据位（低位在前），奇偶校验位（可选），以及停止位。2. 以STM32为例，分析UART工作原理 （1）了解STM32串口主要特性  可编程数据字长度(8位或9位) 可配置的停止位-支持1或2个停止位 可配置的使用DMA的多缓冲器通信 单独的发送器和接收器使能位 检测标志：接收缓冲器满、发送缓冲器空、传输结束标志  （2）了解STM32串口主要寄存器 STM32串口工作流程如下图：   UART工作流程
   状态寄存器USART_SR
  TXE（发送数据寄存器空），当数据全部移入发送移位寄存器时，置1 TC（发送完成），当一帧数据发送完成，且TXE=1时，置1 RXNE（读数据寄存器非空），当有数据读入数据寄存器USART_DR时，置1   数据寄存器USART_DR，发送或接收缓存数据
  控制寄存器1 USART_CR1，主要用于配置中断和使能
  UE（USART使能），TE（发送使能），RE（接收使能） TXEIE 发送缓冲区空中断使能 TCIE 发送完成中断使能 RXNEIE 接收缓冲区非空中断使能  （3）STM32基本配置：波特率，数据位，奇偶校验位，停止位，串口/中断使能 3. UART发送数据 （1）首先是对UART串口的初始化配置 （2）调用函数 HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)  huart是UART句柄结构体（姑且先这么叫） pData是待发送的字符数组，每次发送前都需要进行一次读写，可以调用sprintf函数 Size是指pData字符数组的长度，一般是strlen(pData) Timeout是待发送数据的生存时间，若超时会返回HAL_TIMEOUT  （3）自定义函数usUART_sendString(UART_HandleTypeDef *huart, uint8_t *pData)  这是根据HAL库发送函数由用户进行改写的字符串发送函数，形参只有两个 函数编写借鉴51单片机串口思想，代码编写如下：  void usUart_sendString(UART_HandleTypeDef *huart, uint8_t *pData) { /* 判断是否发送完成 */ while(*pData) { /* 每次发送一个字符 */ HAL_StatusTypeDef HAL_UART_Transmit(huart, pData, 1, 0xffff); /* 字符指针移位，指向下一个字符的内容 */ pData++; } } 4.</description>
			<content type="html"><![CDATA[<h2 id="1-什么是uart">1. 什么是UART？</h2>
<h3 id="1uart通用异步收发器相比于usartuart收发是以字符为单位没有clk同步时钟">（1）UART，通用异步收发器。相比于USART，UART收发是以字符为单位，没有CLK同步时钟。</h3>
<h3 id="2uart最主要的是三根数据线br">（2）UART最主要的是三根数据线：<!-- raw HTML omitted --></h3>
<ul>
<li>TXD发送引脚<!-- raw HTML omitted --></li>
<li>RXD接收引脚<!-- raw HTML omitted --></li>
<li>GND接地引脚<!-- raw HTML omitted --></li>
</ul>
<h3 id="3uart比较重要的几个参数br">（3）UART比较重要的几个参数：<!-- raw HTML omitted --></h3>
<ul>
<li>波特率：每秒传送的码元数，比如9600，115200<!-- raw HTML omitted --></li>
<li>数据位：典型值5、6、8、9位<!-- raw HTML omitted --></li>
<li>奇偶校验位：一般分为奇校验和偶校验或者无校验位<!-- raw HTML omitted --></li>
<li>停止位：典型值1、1.5、2位<!-- raw HTML omitted --></li>
</ul>
<h3 id="4uart工作示意图如下图所示">（4）UART工作示意图如下图所示：</h3>
<figure>
    <img src="https://img-blog.csdnimg.cn/20210210180902920.png"
         alt="image"/> <figcaption>
            <p>UART工作模式</p>
        </figcaption>
</figure>

<p>这是典型的UART异步通信模式，数据位为8，无奇偶校验位，一位停止位。UART串口发送一次包含：起始位，数据位（低位在前），奇偶校验位（可选），以及停止位。<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<h2 id="2-以stm32为例分析uart工作原理">2. 以STM32为例，分析UART工作原理</h2>
<h3 id="1了解stm32串口主要特性">（1）了解STM32串口主要特性</h3>
<ul>
<li>可编程数据字长度(8位或9位)</li>
<li>可配置的停止位-支持1或2个停止位</li>
<li>可配置的使用DMA的多缓冲器通信</li>
<li>单独的发送器和接收器使能位</li>
<li>检测标志：接收缓冲器满、发送缓冲器空、传输结束标志</li>
</ul>
<h3 id="2了解stm32串口主要寄存器">（2）了解STM32串口主要寄存器</h3>
<p>STM32串口工作流程如下图：
<figure>
    <img src="https://img-blog.csdnimg.cn/20210210183410273.png"
         alt="image"/> <figcaption>
            <p>UART工作流程</p>
        </figcaption>
</figure>
</p>
<blockquote>
<p>状态寄存器USART_SR</p>
</blockquote>
<ul>
<li>TXE（发送数据寄存器空），当数据全部移入发送移位寄存器时，置1</li>
<li>TC（发送完成），当一帧数据发送完成，且TXE=1时，置1</li>
<li>RXNE（读数据寄存器非空），当有数据读入数据寄存器USART_DR时，置1</li>
</ul>
<blockquote>
<p>数据寄存器USART_DR，发送或接收缓存数据</p>
</blockquote>
<blockquote>
<p>控制寄存器1 USART_CR1，主要用于配置中断和使能</p>
</blockquote>
<ul>
<li>UE（USART使能），TE（发送使能），RE（接收使能）</li>
<li>TXEIE 发送缓冲区空中断使能</li>
<li>TCIE 发送完成中断使能</li>
<li>RXNEIE 接收缓冲区非空中断使能</li>
</ul>
<h3 id="3stm32基本配置波特率数据位奇偶校验位停止位串口中断使能">（3）STM32基本配置：波特率，数据位，奇偶校验位，停止位，串口/中断使能</h3>
<h2 id="3-uart发送数据">3. UART发送数据</h2>
<h3 id="1首先是对uart串口的初始化配置">（1）首先是对UART串口的初始化配置</h3>
<h3 id="2调用函数-hal_statustypedef-hal_uart_transmituart_handletypedef-huart-uint8_t-pdata-uint16_t-size-uint32_t-timeout">（2）调用函数 <code>HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</code></h3>
<ul>
<li>huart是UART句柄结构体（姑且先这么叫）</li>
<li>pData是待发送的字符数组，每次发送前都需要进行一次读写，可以调用sprintf函数</li>
<li>Size是指pData字符数组的长度，一般是<code>strlen(pData)</code></li>
<li>Timeout是待发送数据的生存时间，若超时会返回HAL_TIMEOUT</li>
</ul>
<h3 id="3自定义函数usuart_sendstringuart_handletypedef-huart-uint8_t-pdata">（3）自定义函数<code>usUART_sendString(UART_HandleTypeDef *huart, uint8_t *pData)</code></h3>
<ul>
<li>这是根据HAL库发送函数由用户进行改写的字符串发送函数，形参只有两个</li>
<li>函数编写借鉴51单片机串口思想，代码编写如下：</li>
</ul>
<pre><code>void usUart_sendString(UART_HandleTypeDef *huart, uint8_t *pData)
{
  /*
  判断是否发送完成
  */
  while(*pData)   
  {
    /*
    每次发送一个字符
    */
    HAL_StatusTypeDef HAL_UART_Transmit(huart, pData, 1, 0xffff);
    /*
    字符指针移位，指向下一个字符的内容
    */
    pData++;
  }
}
</code></pre><h2 id="4-uart接收">4. UART接收</h2>
<h3 id="1首先对uart串口进行初始化">（1）首先对UART串口进行初始化</h3>
<h3 id="2调用函数hal_statustypedef-hal_uart_receiveuart_handletypedef-huart-uint8_t-pdata-uint16_t-size-uint32_t-timeout">（2）调用函数<code>HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</code></h3>
<ul>
<li>采用这种方法一般都是查询法，如下：</li>
</ul>
<pre><code>/* 判断是否接收成功 */
if(HAL_UART_Receive(&amp;huart1, &amp;uRx_Data, 1, 1000) == HAL_OK)
{
  /* 将接收成功的数据通过串口发出来 */
  HAL_UART_Transmit(&amp;huart1, &amp;uRx_Data, 1, 0xffff);
}
</code></pre><ul>
<li>这种方式接收，必须事先知晓接收数据的长度，否则大概率会出错；其次，采用此方法会严重占用MCU的资源，尤其是放到while函数中。</li>
<li>除此之外，若是采用中断的方法，像这样接收后直接处理，就会出现另一个问题，即，还未发送出去（移位寄存器还未清空）就直接进入下一次中断</li>
</ul>
<h3 id="3采用中断方式接收完成后再处理">（3）采用中断方式（接收完成后再处理）</h3>
<ul>
<li>首先需要配置中断，中断配置在此略过……</li>
<li>中断函数代码编写如下：</li>
</ul>
<pre><code>/*
* @brief This function handles USART1 global interrupt.
*/
void USART1_IRQHandler(void)
{
  static unsigned char   uRx_Data[1024] = {0}     ;    //存储数组
  static unsigned char * pRx_Data       = uRx_Data;    //指向存储数组将要存储数据的位
  static unsigned char   uLength        =  0      ;    //接收数据长度

  /* -1- 接收数据 */
  HAL_UART_Receive(&amp;huart1, pRx_Data, 1, 1000);

  /* -2- 判断数据结尾 */
  if(*pRx_Data == '\n')
  {
      /* -3- 将接收成功的数据通过串口发出去 */
      HAL_UART_Transmit(&amp;huart1, uRx_Data, uLength, 0xffff);

      /* -4- 初始化指针和数据长度 */
      pRx_Data = uRx_Data;   //重新指向数组起始位置
      uLength  = 0;          //长度清零
  }
  /* -5- 若未结束，指针往下一位移动，长度自增一 */
  else
  {
      pRx_Data++;
      uLength++;
  }
  HAL_UART_IRQHandler(&amp;huart1);
}
</code></pre><h2 id="参考资料">参考资料</h2>
<p>[1] <a href="https://www.cnblogs.com/ChurF-Lin/p/10809000.html">基于STM32之UART串口通信协议（三）接收</a></p>
<p>[2] <a href="https://www.bilibili.com/video/BV1f7411G7qc?t=217">UART串口通信协议原理</a></p>
]]></content>
		</item>
		
		<item>
			<title>learning_notes_string</title>
			<link>https://hansomxue99.github.io/posts/another/</link>
			<pubDate>Mon, 08 Feb 2021 11:31:14 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/another/</guid>
			<description>1. strlen 运用所出现的问题  strlen 返回值是 size_t，它是一个无符号整型 if(strlen(x) &amp;gt;= strlen(y)) 和 if(strlen(x)-strlen(y) &amp;gt;= 0)其实是不等价的，原因是strlen返回值是一个无符号类型，strlen(x)-strlen(y)也是一个无符号类型，而无符号数绝不会是一个负值。 当然这个问题也是可以解决的，就是把strlen的返回值强制转换为int类型 strlen所计算的字符串长度是不计入&#39;\0&amp;rsquo;或NUL值，思考strlen和sizeof的区别  2. 如何理解长度受限制字符串和长度不受限字符串？ 3. 字符串的复制  string.h 头文件中的 strcpy用于字符串的复制 字符串复制操作前必须保证目标字符串的空间足以容纳需要复制的字符串 新字符串以NUL结尾，旧字符串的后几位将丢失或者删除 理解strncpy的意义，考虑如下代码段  char buffer[BSIZER]; ... strncpy(buffer, name, BSIZE); buffer[BSIZE-1] = &#39;\0&#39;;  上述代码段可以保证 strncpy操作后所得字符串是以NUL结尾  4. 字符串的连接  string.h 头文件中的 strcat用于字符串的连接 同样的，字符串连接操作前必须保证目标字符串的空间足以容纳连接后的字符串 理解strncat字符串  5. 字符串的比较  string.h 头文件中的 strcmp用于字符串的比较 理解“词典比较” 字符串相等：返回0； 大于：返回一个大于0的值； 小于：返回一个小于0的值 理解strncmp字符串  6. 字符串查找  strchr 和 strrchr 函数查找字符出现第一次和最后一次的位置 strpbrk 函数查找一组字符中第一次出现的位置 strstr 函数查找字符子串第一次出现的位置 C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标， strcspn和strspn正好相反 C 库函数 char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。用法如下：   /* 获取第一个子字符串 */ token = strtok(str, s); /* 继续获取其他的子字符串 */ while( token !</description>
			<content type="html"><![CDATA[<h3 id="1-strlen-运用所出现的问题">1. strlen 运用所出现的问题</h3>
<ul>
<li>strlen 返回值是 size_t，它是一个无符号整型</li>
<li><code>if(strlen(x) &gt;= strlen(y)) 和 if(strlen(x)-strlen(y) &gt;= 0)</code>其实是不等价的，原因是strlen返回值是一个无符号类型，strlen(x)-strlen(y)也是一个无符号类型，而无符号数绝不会是一个负值。</li>
<li>当然这个问题也是可以解决的，就是把strlen的返回值强制转换为int类型</li>
<li>strlen所计算的字符串长度是不计入'\0&rsquo;或NUL值，思考strlen和sizeof的区别</li>
</ul>
<h3 id="2-如何理解长度受限制字符串和长度不受限字符串">2. 如何理解长度受限制字符串和长度不受限字符串？</h3>
<h3 id="3-字符串的复制">3. 字符串的复制</h3>
<ul>
<li>string.h 头文件中的 strcpy用于字符串的复制</li>
<li>字符串复制操作前必须保证目标字符串的空间足以容纳需要复制的字符串</li>
<li>新字符串以NUL结尾，旧字符串的后几位将丢失或者删除</li>
<li>理解strncpy的意义，考虑如下代码段</li>
</ul>
<pre><code>char buffer[BSIZER];
...
strncpy(buffer, name, BSIZE);
buffer[BSIZE-1] = '\0';
</code></pre><ul>
<li>上述代码段可以保证 strncpy操作后所得字符串是以NUL结尾</li>
</ul>
<h3 id="4-字符串的连接">4. 字符串的连接</h3>
<ul>
<li>string.h 头文件中的 strcat用于字符串的连接</li>
<li>同样的，字符串连接操作前必须保证目标字符串的空间足以容纳连接后的字符串</li>
<li>理解strncat字符串</li>
</ul>
<h3 id="5-字符串的比较">5. 字符串的比较</h3>
<ul>
<li>string.h 头文件中的 strcmp用于字符串的比较</li>
<li>理解“词典比较”</li>
<li>字符串相等：返回0； 大于：返回一个大于0的值； 小于：返回一个小于0的值</li>
<li>理解strncmp字符串</li>
</ul>
<h3 id="6-字符串查找">6. 字符串查找</h3>
<ul>
<li>strchr 和 strrchr 函数查找字符出现第一次和最后一次的位置</li>
<li>strpbrk 函数查找一组字符中第一次出现的位置</li>
<li>strstr 函数查找字符子串第一次出现的位置</li>
<li>C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标， strcspn和strspn正好相反</li>
<li>C 库函数 char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。用法如下：</li>
</ul>
<pre><code> /* 获取第一个子字符串 */
   token = strtok(str, s);
   
   /* 继续获取其他的子字符串 */
   while( token != NULL ) {
      printf( &quot;%s\n&quot;, token );
    
      token = strtok(NULL, s);
   }
</code></pre><pre><code>for(token=strtok(str,s); token!=NULL; token=strtok(NULL,s)){
    printf(&quot;%s\n&quot;, token);
}
</code></pre><ul>
<li>C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。用法如下：</li>
</ul>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main ()
{
   FILE *fp;

   fp = fopen(&quot;file.txt&quot;,&quot;r&quot;);
   if( fp == NULL ) 
   {
      printf(&quot;Error: %s\n&quot;, strerror(errno));
   }
   
  return(0);
}

结果显示：Error: No such file or directory
</code></pre>]]></content>
		</item>
		
		<item>
			<title>STM32学习笔记——寄存器映射</title>
			<link>https://hansomxue99.github.io/posts/myfirstblog/</link>
			<pubDate>Mon, 08 Feb 2021 11:06:24 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/myfirstblog/</guid>
			<description>存储器映射  总线基地址     总线名称 总线基地址      APB1 0x4000 0000    APB2 0x4001 0000    AHB 0x4000 8000     GPIO基地址  GPIO端口挂在总线APB2上
   端口名称 端口基地址      GPIOA 0x4001 0800    GPIOB 0x4001 0C00    GPIOC 0x4001 1000    GPIOD 0x4001 1400    GPIOE 0x4001 1800    GPIOF 0x4001 1C00    GPIOG 0x4001 2000     每个端口的基地址相差0x400</description>
			<content type="html"><![CDATA[<h1 id="存储器映射">存储器映射</h1>
<ol>
<li>总线基地址</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">总线名称</th>
<th style="text-align:center">总线基地址</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APB1</td>
<td style="text-align:center">0x4000 0000</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">APB2</td>
<td style="text-align:center">0x4001 0000</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">AHB</td>
<td style="text-align:center">0x4000 8000</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>GPIO基地址</li>
</ol>
<p>GPIO端口挂在总线APB2上</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口名称</th>
<th style="text-align:center">端口基地址</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GPIOA</td>
<td style="text-align:center">0x4001 0800</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB</td>
<td style="text-align:center">0x4001 0C00</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOC</td>
<td style="text-align:center">0x4001 1000</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOD</td>
<td style="text-align:center">0x4001 1400</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOE</td>
<td style="text-align:center">0x4001 1800</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOF</td>
<td style="text-align:center">0x4001 1C00</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOG</td>
<td style="text-align:center">0x4001 2000</td>
<td></td>
</tr>
</tbody>
</table>
<p>每个端口的基地址相差0x400</p>
<ol start="3">
<li>GPIOx端口的寄存器列表</li>
</ol>
<p>以GPIOB端口为例</p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器名称</th>
<th style="text-align:center">寄存器基地址</th>
<th style="text-align:center">偏移地址</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GPIOB_CRL</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x00</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_CRH</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x04</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_IDR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x08</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_ODR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x0C</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_BSRR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x10</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_BRR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x14</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_LCKR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x18</td>
<td></td>
</tr>
</tbody>
</table>
<p>每个寄存器地址相差0x04</p>
<h1 id="gpiob端口寄存器描述使pb0输出01">GPIOB端口寄存器描述——使PB0输出0/1</h1>
<h2 id="宏定义方式">宏定义方式</h2>
<pre><code>#define PERIPH_BASE			((unsigned int)0x40000000)
#define APB2PERIPH_BASE		(PERIPH_BASE + 0x00010000)
#define GPIO_BASE			(APB2PERIPH_BASE + 0x0C00)
#define GPIO_ODR			*(unisgned int*)(GPIO_BASE + 0x0C)

//PB0输出低电平
GPIO_ODR &amp;= ~(1&lt;&lt;0);
//PB0输出高电平
GPIO_ODR |= (1&lt;&lt;0)
</code></pre><p>（GPIO_BASE + 0x0C）对应GPIO_ODR寄存器地址
（unsigned int*） 将（GPIO_BASE + 0x0C）强制转化为指针
（*）指针操作，指向GPIO_ODR地址</p>
<h2 id="结构体封装">结构体封装</h2>
<pre><code>typedef unsigned int 	uint32_t;		 /*无符号32位变量*/
typedef unsigned short int	uint16_t;	/*无符号16位变量*/

/*GPIO寄存器列表*/
typedef struct{
	uint32_t 	CRL;	/*地址偏移0x00*/
	uint32_t	CRH;	/*地址偏移0x04*/
	uint32_t	IDR;	/*地址偏移0x08*/
	uint32_t	ODR;	/*地址偏移0x0C*/
	uint32_t	BSRR;	/*地址偏移0x10*/
	uint32_t	BRR;	/*地址偏移0x14*/
	uint32_t	LCKR;	/*地址偏移0x18*/
}GPIO_TypeDef;

GPIO_TypeDef* GPIOx;
GPIOx = GPIO_BASE;
GPIO-&gt;ODR = 0xFFFFE;
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
