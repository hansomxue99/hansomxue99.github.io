<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on hansomxue99&#39;s blog</title>
		<link>https://hansomxue99.github.io/posts/</link>
		<description>Recent content in Posts on hansomxue99&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-CN</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 08 Feb 2021 11:31:14 +0800</lastBuildDate>
		<atom:link href="https://hansomxue99.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>learning_notes_string</title>
			<link>https://hansomxue99.github.io/posts/another/</link>
			<pubDate>Mon, 08 Feb 2021 11:31:14 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/another/</guid>
			<description>1. strlen 运用所出现的问题  strlen 返回值是 size_t，它是一个无符号整型 if(strlen(x) &amp;gt;= strlen(y)) 和 if(strlen(x)-strlen(y) &amp;gt;= 0)其实是不等价的，原因是strlen返回值是一个无符号类型，strlen(x)-strlen(y)也是一个无符号类型，而无符号数绝不会是一个负值。 当然这个问题也是可以解决的，就是把strlen的返回值强制转换为int类型 strlen所计算的字符串长度是不计入&#39;\0&amp;rsquo;或NUL值，思考strlen和sizeof的区别  2. 如何理解长度受限制字符串和长度不受限字符串？ 3. 字符串的复制  string.h 头文件中的 strcpy用于字符串的复制 字符串复制操作前必须保证目标字符串的空间足以容纳需要复制的字符串 新字符串以NUL结尾，旧字符串的后几位将丢失或者删除 理解strncpy的意义，考虑如下代码段  char buffer[BSIZER]; ... strncpy(buffer, name, BSIZE); buffer[BSIZE-1] = &#39;\0&#39;;  上述代码段可以保证 strncpy操作后所得字符串是以NUL结尾  4. 字符串的连接  string.h 头文件中的 strcat用于字符串的连接 同样的，字符串连接操作前必须保证目标字符串的空间足以容纳连接后的字符串 理解strncat字符串  5. 字符串的比较  string.h 头文件中的 strcmp用于字符串的比较 理解“词典比较” 字符串相等：返回0； 大于：返回一个大于0的值； 小于：返回一个小于0的值 理解strncmp字符串  6. 字符串查找  strchr 和 strrchr 函数查找字符出现第一次和最后一次的位置 strpbrk 函数查找一组字符中第一次出现的位置 strstr 函数查找字符子串第一次出现的位置 C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标， strcspn和strspn正好相反 C 库函数 char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。用法如下：   /* 获取第一个子字符串 */ token = strtok(str, s); /* 继续获取其他的子字符串 */ while( token !</description>
			<content type="html"><![CDATA[<h3 id="1-strlen-运用所出现的问题">1. strlen 运用所出现的问题</h3>
<ul>
<li>strlen 返回值是 size_t，它是一个无符号整型</li>
<li><code>if(strlen(x) &gt;= strlen(y)) 和 if(strlen(x)-strlen(y) &gt;= 0)</code>其实是不等价的，原因是strlen返回值是一个无符号类型，strlen(x)-strlen(y)也是一个无符号类型，而无符号数绝不会是一个负值。</li>
<li>当然这个问题也是可以解决的，就是把strlen的返回值强制转换为int类型</li>
<li>strlen所计算的字符串长度是不计入'\0&rsquo;或NUL值，思考strlen和sizeof的区别</li>
</ul>
<h3 id="2-如何理解长度受限制字符串和长度不受限字符串">2. 如何理解长度受限制字符串和长度不受限字符串？</h3>
<h3 id="3-字符串的复制">3. 字符串的复制</h3>
<ul>
<li>string.h 头文件中的 strcpy用于字符串的复制</li>
<li>字符串复制操作前必须保证目标字符串的空间足以容纳需要复制的字符串</li>
<li>新字符串以NUL结尾，旧字符串的后几位将丢失或者删除</li>
<li>理解strncpy的意义，考虑如下代码段</li>
</ul>
<pre><code>char buffer[BSIZER];
...
strncpy(buffer, name, BSIZE);
buffer[BSIZE-1] = '\0';
</code></pre><ul>
<li>上述代码段可以保证 strncpy操作后所得字符串是以NUL结尾</li>
</ul>
<h3 id="4-字符串的连接">4. 字符串的连接</h3>
<ul>
<li>string.h 头文件中的 strcat用于字符串的连接</li>
<li>同样的，字符串连接操作前必须保证目标字符串的空间足以容纳连接后的字符串</li>
<li>理解strncat字符串</li>
</ul>
<h3 id="5-字符串的比较">5. 字符串的比较</h3>
<ul>
<li>string.h 头文件中的 strcmp用于字符串的比较</li>
<li>理解“词典比较”</li>
<li>字符串相等：返回0； 大于：返回一个大于0的值； 小于：返回一个小于0的值</li>
<li>理解strncmp字符串</li>
</ul>
<h3 id="6-字符串查找">6. 字符串查找</h3>
<ul>
<li>strchr 和 strrchr 函数查找字符出现第一次和最后一次的位置</li>
<li>strpbrk 函数查找一组字符中第一次出现的位置</li>
<li>strstr 函数查找字符子串第一次出现的位置</li>
<li>C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标， strcspn和strspn正好相反</li>
<li>C 库函数 char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。用法如下：</li>
</ul>
<pre><code> /* 获取第一个子字符串 */
   token = strtok(str, s);
   
   /* 继续获取其他的子字符串 */
   while( token != NULL ) {
      printf( &quot;%s\n&quot;, token );
    
      token = strtok(NULL, s);
   }
</code></pre><pre><code>for(token=strtok(str,s); token!=NULL; token=strtok(NULL,s)){
    printf(&quot;%s\n&quot;, token);
}
</code></pre><ul>
<li>C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。用法如下：</li>
</ul>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main ()
{
   FILE *fp;

   fp = fopen(&quot;file.txt&quot;,&quot;r&quot;);
   if( fp == NULL ) 
   {
      printf(&quot;Error: %s\n&quot;, strerror(errno));
   }
   
  return(0);
}

结果显示：Error: No such file or directory
</code></pre>]]></content>
		</item>
		
		<item>
			<title>STM32学习笔记——寄存器映射</title>
			<link>https://hansomxue99.github.io/posts/myfirstblog/</link>
			<pubDate>Mon, 08 Feb 2021 11:06:24 +0800</pubDate>
			
			<guid>https://hansomxue99.github.io/posts/myfirstblog/</guid>
			<description>存储器映射  总线基地址     总线名称 总线基地址      APB1 0x4000 0000    APB2 0x4001 0000    AHB 0x4000 8000     GPIO基地址  GPIO端口挂在总线APB2上
   端口名称 端口基地址      GPIOA 0x4001 0800    GPIOB 0x4001 0C00    GPIOC 0x4001 1000    GPIOD 0x4001 1400    GPIOE 0x4001 1800    GPIOF 0x4001 1C00    GPIOG 0x4001 2000     每个端口的基地址相差0x400</description>
			<content type="html"><![CDATA[<h1 id="存储器映射">存储器映射</h1>
<ol>
<li>总线基地址</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">总线名称</th>
<th style="text-align:center">总线基地址</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APB1</td>
<td style="text-align:center">0x4000 0000</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">APB2</td>
<td style="text-align:center">0x4001 0000</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">AHB</td>
<td style="text-align:center">0x4000 8000</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>GPIO基地址</li>
</ol>
<p>GPIO端口挂在总线APB2上</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口名称</th>
<th style="text-align:center">端口基地址</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GPIOA</td>
<td style="text-align:center">0x4001 0800</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB</td>
<td style="text-align:center">0x4001 0C00</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOC</td>
<td style="text-align:center">0x4001 1000</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOD</td>
<td style="text-align:center">0x4001 1400</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOE</td>
<td style="text-align:center">0x4001 1800</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOF</td>
<td style="text-align:center">0x4001 1C00</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOG</td>
<td style="text-align:center">0x4001 2000</td>
<td></td>
</tr>
</tbody>
</table>
<p>每个端口的基地址相差0x400</p>
<ol start="3">
<li>GPIOx端口的寄存器列表</li>
</ol>
<p>以GPIOB端口为例</p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器名称</th>
<th style="text-align:center">寄存器基地址</th>
<th style="text-align:center">偏移地址</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GPIOB_CRL</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x00</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_CRH</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x04</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_IDR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x08</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_ODR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x0C</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_BSRR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x10</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_BRR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x14</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">GPIOB_LCKR</td>
<td style="text-align:center">0x4001 0C00</td>
<td style="text-align:center">0x18</td>
<td></td>
</tr>
</tbody>
</table>
<p>每个寄存器地址相差0x04</p>
<h1 id="gpiob端口寄存器描述使pb0输出01">GPIOB端口寄存器描述——使PB0输出0/1</h1>
<h2 id="宏定义方式">宏定义方式</h2>
<pre><code>#define PERIPH_BASE			((unsigned int)0x40000000)
#define APB2PERIPH_BASE		(PERIPH_BASE + 0x00010000)
#define GPIO_BASE			(APB2PERIPH_BASE + 0x0C00)
#define GPIO_ODR			*(unisgned int*)(GPIO_BASE + 0x0C)

//PB0输出低电平
GPIO_ODR &amp;= ~(1&lt;&lt;0);
//PB0输出高电平
GPIO_ODR |= (1&lt;&lt;0)
</code></pre><p>（GPIO_BASE + 0x0C）对应GPIO_ODR寄存器地址
（unsigned int*） 将（GPIO_BASE + 0x0C）强制转化为指针
（*）指针操作，指向GPIO_ODR地址</p>
<h2 id="结构体封装">结构体封装</h2>
<pre><code>typedef unsigned int 	uint32_t;		 /*无符号32位变量*/
typedef unsigned short int	uint16_t;	/*无符号16位变量*/

/*GPIO寄存器列表*/
typedef struct{
	uint32_t 	CRL;	/*地址偏移0x00*/
	uint32_t	CRH;	/*地址偏移0x04*/
	uint32_t	IDR;	/*地址偏移0x08*/
	uint32_t	ODR;	/*地址偏移0x0C*/
	uint32_t	BSRR;	/*地址偏移0x10*/
	uint32_t	BRR;	/*地址偏移0x14*/
	uint32_t	LCKR;	/*地址偏移0x18*/
}GPIO_TypeDef;

GPIO_TypeDef* GPIOx;
GPIOx = GPIO_BASE;
GPIO-&gt;ODR = 0xFFFFE;
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
