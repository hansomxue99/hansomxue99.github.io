<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# on Team&#39;s blog</title>
    <link>https://hansomxue99.github.io/tags/c#/</link>
    <description>Recent content in C# on Team&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 26 Apr 2021 20:28:28 +0800</lastBuildDate><atom:link href="https://hansomxue99.github.io/tags/c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C#声音捕获基础</title>
      <link>https://hansomxue99.github.io/posts/c_capturesound/</link>
      <pubDate>Mon, 26 Apr 2021 20:28:28 +0800</pubDate>
      
      <guid>https://hansomxue99.github.io/posts/c_capturesound/</guid>
      <description>using Microsoft.DirectX.DirectSound;
  Capture;	//音频捕捉设备 CaptureBuffer;	//缓冲区对象 WaveFormat;	//录音格式   设置录音参数
private WaveFormat mWaveFormat; private WaveFormat CreateWaveFormat() { WaveFormat waveformat = new WaveFormat(); waveformat.FormatTag = WaveFormatTag.Pcm;	//音频类型设为PCM  waveformat.SamplesPerSecond = 11025;	//采样率典型值：11025、22050、44100Hz(为了简化程序，暂且设为定值)  waveformat.BitsPerSample = 16;	//采样位数  waveformat.Channels = 2;	//声道：1单声道，2立体声  waveformat.BlockAlign = (short)(waveformat.Channels * (waveformat.BitsPerSample / 8));//单位采样点的字节数  waveformat.AverageBytesPerSecond = waveformat.BlockAlign * waveformat.SamplesPerSecond; return waveformat; // 按照以上采样规格，可知采样1秒钟的字节数为 11025*2=32000B 约为22K } //mWaveFormat = CreateWaveFormat();   初始化录音设备</description>
    </item>
    
    <item>
      <title>C#多线程</title>
      <link>https://hansomxue99.github.io/posts/c_multithread/</link>
      <pubDate>Mon, 26 Apr 2021 20:27:32 +0800</pubDate>
      
      <guid>https://hansomxue99.github.io/posts/c_multithread/</guid>
      <description>C# 多线程 1. 创建线程 首先必须导入命名空间 using System.Threading; 创建的线程包括无参数和有参数。
//创建无参线程 Thread t1 = new Thread(new ThreadStart(PrintNumbers));	//无参数的委托 t1.Start(); static void PrintNumbers(){...} //创建有参线程 Thread t2 = new Thread(new ParameterizedThreadStart(PrintNumbers));	//有参数的委托 t2.Start(10); static void PrintNumbers(object count){...}	//参数类型声明为object 2. AutoResetEvent 1）对象实例化
AutoResetEvent autoResetEvent = new AutoResetEvent(false); false：无信号，子线程的WaitOne方法不会被自动调用
true：有信号，子线程的WaitOne方法会被自动调用
2）WaitOne 方法
组织当前线程继续运行，等待其他线程发送信号。
3）Set方法
示例：
static AutoResetEvent autoResetEvent = new AutoResetEvent(true); static void Main(string[] args) { //开启一个读线程(子线程)  Thread readerThread = new Thread(new ThreadStart(ReadThreadProc)); readerThread.Name = &amp;#34;ReaderThread&amp;#34;; readerThread.</description>
    </item>
    
    <item>
      <title>C#窗体程序基础</title>
      <link>https://hansomxue99.github.io/posts/c_winform/</link>
      <pubDate>Mon, 26 Apr 2021 20:26:42 +0800</pubDate>
      
      <guid>https://hansomxue99.github.io/posts/c_winform/</guid>
      <description>Form和Form.Designer的关系：Form的构造方法调用了Form.Designer中的InitializeComponent方法
  读取时间：
string timeStr = DateTime.Now.ToString(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); //文本框显示 textBox.Text = timeStr;   两个字段属性的区别：Name和Text。
  手工布局——&amp;gt;窗口自适应
//重写父类的方法 protected override void Onlayout(LayoutEventArgs levent) { //1. 调用父类的layout  base.OnLayout(levent); //2. 获取客户区的窗口大小 ClientSize(注意是客户区，不包含标题栏)  int w = this.ClientSize.Width; int h = this.ClientSize.Height; //3. 根据需求，计算每一个控件的大小和位置 } 注意：文本框AutoSize设为false；窗口大小改变时，系统框架会自动调用OnLayout()方法。
  Anchor和Dock属性不能同时设置
  textbox
private void box1_Keypress(object sender, KeypressEventArgs e) { char ch = e.KeyChar; if(ch == &amp;#39;\r&amp;#39;) { string str = box1.</description>
    </item>
    
    <item>
      <title>C#面向对象</title>
      <link>https://hansomxue99.github.io/posts/c_class/</link>
      <pubDate>Mon, 26 Apr 2021 20:23:44 +0800</pubDate>
      
      <guid>https://hansomxue99.github.io/posts/c_class/</guid>
      <description>C#面向对象 1. 新建类和创建对象 //新建类 public class Point{ public int x,y;	//成员变量  public Piont(int x, int y){	//构造函数：函数名与类名一致，用于给对象初始化  this.x = x; this.y = y; } } //创建对象 Point p1 = new Piont(10,10);	//new关键字新建对象 2. 创建子类 //创建Piont的子类Point3D public class Point3D: Point{ public int z;	//子类对象会继承父类的public类型的成员 	public Point3D(int x, int y, int z){ //省略Point(x,y);这是因为在创建子类时，父类已经初始化，不必重复声明 	this.z = z;	//只需执行z的初始化 	} } //创建Point3D对象 //第一种方法 Point3D p2 = new Point3D(10,20,30); //第二种方法 Point p2 = new Point3D(10,20,30); 3.</description>
    </item>
    
  </channel>
</rss>
